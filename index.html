<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARRI Framelines Visualizer - Multi-Camera Support</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #fff;
            font-size: 28px;
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            color: #888;
            font-size: 14px;
        }
        
        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 14px;
        }

        select {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }

        select:hover {
            border-color: #0066cc;
        }

        select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        input[type="file"] {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
        }
        
        input[type="file"]::file-selector-button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        input[type="file"]::file-selector-button:hover {
            background: #0052a3;
        }
        
        .bg-option-btn {
            background: #0066cc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            flex: 1;
            font-size: 13px;
            transition: background 0.2s;
        }
        
        .bg-option-btn:hover {
            background: #0052a3;
        }
        
        .bg-option-btn.active {
            background: #00cc66;
        }
        
        .viewer {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 600px;
        }
        
        .canvas-container {
            position: relative;
            background: #000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        
        canvas {
            display: block;
            image-rendering: crisp-edges;
        }
        
        .info {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .info h3 {
            margin-bottom: 10px;
            color: #fff;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .info-item {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
        }
        
        .info-label {
            color: #888;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .info-value {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
        }
        
        .error {
            background: #ff4444;
            color: white;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }

        .popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .popup-content {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .popup-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            color: #888;
            cursor: pointer;
        }

        .popup-close:hover {
            color: #fff;
        }

        .popup-title {
            font-size: 20px;
            margin-bottom: 20px;
            color: #fff;
        }

        .xml-file-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .xml-file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #1a1a1a;
            border-radius: 4px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .xml-file-item:hover {
            background: #3a3a3a;
        }

        .xml-file-name {
            font-size: 14px;
            color: #ccc;
        }

        .xml-file-download {
            font-size: 13px;
            color: #0066cc;
            text-decoration: none;
            transition: color 0.2s;
        }

        .xml-file-download:hover {
            color: #0088ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ARRI Framelines Visualizer</h1>
        <div class="subtitle">Multi-camera support for all ARRI formats</div>
        
        <div class="error" id="error"></div>

        <div class="controls">
            <div class="control-group">
                <label for="cameraSelect">Select Camera Model:</label>
                <select id="cameraSelect">
                    <option value="">-- Select Camera --</option>
                </select>
            </div>
            <div class="control-group">
                <label for="formatSelect">Select Format:</label>
                <select id="formatSelect" disabled>
                    <option value="">-- Select Camera First --</option>
                </select>
            </div>
            <div class="control-group">
                <label for="xmlFile">Load Framelines XML File:</label>
                <div style="display: flex; gap: 10px;">
                    <input type="file" id="xmlFile" accept=".xml" style="flex: 1;" />
                    <button id="selectFromLibrary" class="bg-option-btn">Select from Library</button>
                </div>
            </div>
            <div class="control-group">
                <label>Background Options:</label>
                <div style="display: flex; gap: 10px; margin-top: 8px;">
                    <button id="useCustomImage" class="bg-option-btn">Upload Custom Image</button>
                    <button id="useSampleImage" class="bg-option-btn">Use Sample Image</button>
                    <button id="useGreyGrid" class="bg-option-btn">Use Grey Grid</button>
                </div>
                <input type="file" id="bgImage" accept="image/*" style="display: none;" />
            </div>
        </div>
        
        <div class="viewer">
            <div class="canvas-container">
                <canvas id="frameCanvas"></canvas>
            </div>
        </div>
        
        <div class="info">
            <h3>Camera Information</h3>
            <div class="info-grid" id="cameraInfo"></div>
        </div>
    </div>

    <div id="xmlLibraryPopup" class="popup">
        <div class="popup-content">
            <span class="popup-close" id="closePopup">&times;</span>
            <h3 class="popup-title">Select Frameline from Library</h3>
            <ul class="xml-file-list" id="xmlFileList">
                <!-- File items will be injected here by JavaScript -->
            </ul>
        </div>
    </div>
    
    <footer style="text-align: center; margin-top: 30px; padding: 20px; color: #888; font-size: 14px;">
        You don't like it? Please fix it yourself :D Here's the github: <a href="https://github.com/JensS/arri-frameline-visualizer" style="color: #0066cc; text-decoration: none;">https://github.com/JensS/arri-frameline-visualizer</a>
        <br><br>
        <a href="https://ko-fi.com/jenssage" style="color: #0066cc; text-decoration: none;">â˜• Buy me a Ko-Fi</a>
    </footer>
    
    <script>
        const canvas = document.getElementById('frameCanvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('xmlFile');
        const bgImageInput = document.getElementById('bgImage');
        const errorDiv = document.getElementById('error');
        const cameraInfoDiv = document.getElementById('cameraInfo');
        const useCustomImageBtn = document.getElementById('useCustomImage');
        const useSampleImageBtn = document.getElementById('useSampleImage');
        const useGreyGridBtn = document.getElementById('useGreyGrid');
        const selectFromLibraryBtn = document.getElementById('selectFromLibrary');
        const xmlLibraryPopup = document.getElementById('xmlLibraryPopup');
        const closePopupBtn = document.getElementById('closePopup');
        const xmlFileList = document.getElementById('xmlFileList');
        const cameraSelect = document.getElementById('cameraSelect');
        const formatSelect = document.getElementById('formatSelect');

        const xmlFiles = ["A-Mini_4x3-2_8K_social-blackouts.xml", "A-Mini_4x3-2.8K_socials.xml"];

        let frameData = null;
        let backgroundImage = null;
        let imageLoaded = false;
        let useGreyGrid = false;
        let cameraFormats = null;
        let selectedCamera = null;
        let selectedFormat = null;
        
        // Sample image path
        const sampleImagePath = 'sample-image-jens-sage-2880-2160.jpg';

        // Load camera formats from JSON
        async function loadCameraFormats() {
            try {
                const response = await fetch('arri_camera_formats.json');
                cameraFormats = await response.json();
                populateCameraDropdown();
            } catch (error) {
                showError('Failed to load camera formats: ' + error.message);
                console.error(error);
            }
        }

        // Populate camera dropdown
        function populateCameraDropdown() {
            if (!cameraFormats || !cameraFormats.cameras) return;

            cameraSelect.innerHTML = '<option value="">-- Select Camera --</option>';

            cameraFormats.cameras.forEach((camera, index) => {
                const option = document.createElement('option');
                option.value = index;
                const variantText = camera.variant ? ` (${camera.variant})` : '';
                option.textContent = `${camera.model}${variantText}`;
                cameraSelect.appendChild(option);
            });
        }

        // Populate format dropdown based on selected camera
        function populateFormatDropdown(cameraIndex) {
            formatSelect.innerHTML = '<option value="">-- Select Format --</option>';
            formatSelect.disabled = false;

            const camera = cameraFormats.cameras[cameraIndex];
            if (!camera || !camera.formats) return;

            camera.formats.forEach((format, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = format.name;
                formatSelect.appendChild(option);
            });
        }

        // Get aspect ratio from format
        function getAspectRatio(format) {
            return format.sensor_photosites.h / format.sensor_photosites.v;
        }

        // Calculate aspect ratio tolerance (5% tolerance)
        function isAspectRatioCompatible(imageAspect, formatAspect, tolerance = 0.05) {
            const ratio = imageAspect / formatAspect;
            return ratio >= (1 - tolerance) && ratio <= (1 + tolerance);
        }

        // Handle camera selection
        cameraSelect.addEventListener('change', (e) => {
            const cameraIndex = parseInt(e.target.value);
            if (isNaN(cameraIndex)) {
                formatSelect.innerHTML = '<option value="">-- Select Camera First --</option>';
                formatSelect.disabled = true;
                selectedCamera = null;
                selectedFormat = null;
                cameraInfoDiv.innerHTML = '';
                return;
            }

            selectedCamera = cameraFormats.cameras[cameraIndex];
            selectedFormat = null;
            populateFormatDropdown(cameraIndex);
            updateFormatInfo();
        });

        // Handle format selection
        formatSelect.addEventListener('change', (e) => {
            const formatIndex = parseInt(e.target.value);
            if (isNaN(formatIndex) || !selectedCamera) {
                selectedFormat = null;
                return;
            }

            selectedFormat = selectedCamera.formats[formatIndex];

            // Redraw if we have frame data
            if (frameData) {
                drawFramelines(frameData);
            } else {
                drawPlaceholder();
            }

            // Update info display
            updateFormatInfo();
        });

        // Update format info display
        function updateFormatInfo() {
            let infoHtml = '';

            // Show selected camera information
            if (selectedCamera) {
                const variantText = selectedCamera.variant ? ` (${selectedCamera.variant})` : '';
                infoHtml += `
                    <div class="info-item">
                        <div class="info-label">Selected Camera</div>
                        <div class="info-value">${selectedCamera.model}${variantText}</div>
                    </div>
                `;

                if (selectedCamera.sup_version) {
                    infoHtml += `
                        <div class="info-item">
                            <div class="info-label">SUP Version</div>
                            <div class="info-value">${selectedCamera.sup_version}</div>
                        </div>
                    `;
                }
            }

            // Show selected format information
            if (selectedFormat) {
                const aspectRatio = getAspectRatio(selectedFormat);
                infoHtml += `
                    <div class="info-item">
                        <div class="info-label">Selected Format</div>
                        <div class="info-value">${selectedFormat.name}</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Recording Resolution</div>
                        <div class="info-value">${selectedFormat.recording_resolution || 'N/A'}</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Sensor Resolution</div>
                        <div class="info-value">${selectedFormat.sensor_photosites.h} Ã— ${selectedFormat.sensor_photosites.v}</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Aspect Ratio</div>
                        <div class="info-value">${aspectRatio.toFixed(2)}:1</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Sensor Active Area</div>
                        <div class="info-value">${selectedFormat.sensor_area_mm.h} Ã— ${selectedFormat.sensor_area_mm.v} mm</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Sensor Active Area (inches)</div>
                        <div class="info-value">${selectedFormat.sensor_area_inch.h}" Ã— ${selectedFormat.sensor_area_inch.v}"</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Image Circle</div>
                        <div class="info-value">${selectedFormat.image_circle_mm} mm (${selectedFormat.image_circle_inch}")</div>
                    </div>
                `;

                // Show codecs if available
                if (selectedFormat.codecs && selectedFormat.codecs.length > 0) {
                    const codecsList = selectedFormat.codecs.map(c => c.codec).join(', ');
                    infoHtml += `
                        <div class="info-item">
                            <div class="info-label">Available Codecs</div>
                            <div class="info-value">${codecsList}</div>
                        </div>
                    `;
                }
            }

            if (infoHtml) {
                cameraInfoDiv.innerHTML = infoHtml;
            }
        }

        // Set active button
        function setActiveButton(activeBtn) {
            [useCustomImageBtn, useSampleImageBtn, useGreyGridBtn].forEach(btn => {
                btn.classList.remove('active');
            });
            activeBtn.classList.add('active');
        }
        
        // Load sample image
        function loadSampleImage() {
            const img = new Image();
            img.onload = function() {
                // Validate aspect ratio if format is selected
                if (selectedFormat) {
                    const imageAspect = img.width / img.height;
                    const formatAspect = getAspectRatio(selectedFormat);

                    if (!isAspectRatioCompatible(imageAspect, formatAspect)) {
                        showError(`Sample image aspect ratio (${imageAspect.toFixed(2)}:1) does not match the selected format (${formatAspect.toFixed(2)}:1). Consider using a different background or grey grid.`);
                    }
                }

                backgroundImage = img;
                imageLoaded = true;
                useGreyGrid = false;
                if (frameData) {
                    drawFramelines(frameData);
                } else {
                    drawPlaceholder();
                }
            };
            img.onerror = function() {
                showError('Could not load sample image. Using grey grid instead.');
                useGreyGrid = true;
                imageLoaded = false;
                if (frameData) {
                    drawFramelines(frameData);
                } else {
                    drawPlaceholder();
                }
            };
            img.src = sampleImagePath;
        }
        
        // Handle local image upload
        bgImageInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const localImg = new Image();
                localImg.onload = function() {
                    // Validate aspect ratio if format is selected
                    if (selectedFormat) {
                        const imageAspect = localImg.width / localImg.height;
                        const formatAspect = getAspectRatio(selectedFormat);

                        if (!isAspectRatioCompatible(imageAspect, formatAspect)) {
                            showError(`Image aspect ratio (${imageAspect.toFixed(2)}:1) does not match the selected format (${formatAspect.toFixed(2)}:1). Image may appear stretched or cropped.`);
                        }
                    }

                    backgroundImage = localImg;
                    imageLoaded = true;
                    useGreyGrid = false;
                    setActiveButton(useCustomImageBtn);
                    if (frameData) {
                        drawFramelines(frameData);
                    } else {
                        drawPlaceholder();
                    }
                };
                localImg.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
        
        // Button event handlers
        useCustomImageBtn.addEventListener('click', () => {
            bgImageInput.click();
        });
        
        useSampleImageBtn.addEventListener('click', () => {
            setActiveButton(useSampleImageBtn);
            loadSampleImage();
        });
        
        useGreyGridBtn.addEventListener('click', () => {
            setActiveButton(useGreyGridBtn);
            backgroundImage = null;
            imageLoaded = false;
            useGreyGrid = true;
            if (frameData) {
                drawFramelines(frameData);
            } else {
                drawPlaceholder();
            }
        });
        
        function showError(message) {
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }
        
        function parseXML(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            
            const errorNode = xmlDoc.querySelector('parsererror');
            if (errorNode) {
                throw new Error('Invalid XML file');
            }
            
            const camera = {
                type: xmlDoc.querySelector('camera > type')?.textContent || 'Unknown',
                sensor: xmlDoc.querySelector('camera > sensor')?.textContent || 'Unknown',
                aspect: parseFloat(xmlDoc.querySelector('camera > aspect')?.textContent || '1.33'),
                hres: parseInt(xmlDoc.querySelector('camera > hres')?.textContent || '2880'),
                vres: parseInt(xmlDoc.querySelector('camera > vres')?.textContent || '2160')
            };
            
            // Try to extract sensor dimensions from comments
            const sensorAreaMatch = xmlText.match(/sensor active image area:\s*([\d.]+)mm\s*x\s*([\d.]+)mm/i);
            if (sensorAreaMatch) {
                camera.physicalWidth = parseFloat(sensorAreaMatch[1]);
                camera.physicalHeight = parseFloat(sensorAreaMatch[2]);
            }
            
            // Extract recording format from comments
            const recordingFormatMatch = xmlText.match(/recording format:\s*(.+?)(?:\n|$)/);
            if (recordingFormatMatch) {
                camera.recordingFormat = recordingFormatMatch[1].trim();
            }
            
            const rects = [];
            const rectElements = xmlDoc.querySelectorAll('rect');
            rectElements.forEach(rect => {
                const top = parseFloat(rect.querySelector('top')?.textContent || '0');
                const bottom = parseFloat(rect.querySelector('bottom')?.textContent || '0');
                const left = parseFloat(rect.querySelector('left')?.textContent || '0');
                const right = parseFloat(rect.querySelector('right')?.textContent || '0');
                const opacity = parseFloat(rect.querySelector('fill > opacity')?.textContent || '0');
                const color = rect.querySelector('fill > color')?.textContent || 'black';
                
                rects.push({ top, bottom, left, right, opacity, color });
            });
            
            const lines = [];
            const framelineNames = {};

            // Parse frameline names
            const framelineNameElements = xmlDoc.querySelectorAll('framelineName');
            framelineNameElements.forEach(element => {
                const framelineRect = element.getAttribute('framelineRect');
                const name = element.textContent;
                if (framelineRect && name) {
                    framelineNames[framelineRect] = name;
                }
            });

            // Parse lines
            const lineElements = xmlDoc.querySelectorAll('line');
            lineElements.forEach(line => {
                const framelineRect = line.getAttribute('framelineRect');
                const top = parseFloat(line.querySelector('top')?.textContent || '0');
                const bottom = parseFloat(line.querySelector('bottom')?.textContent || '0');
                const left = parseFloat(line.querySelector('left')?.textContent || '0');
                const right = parseFloat(line.querySelector('right')?.textContent || '0');
                const width = parseInt(line.querySelector('width')?.textContent || '2');
                const color = line.querySelector('color')?.textContent || 'user';

                if (framelineRect) {
                    lines.push({ framelineRect, top, bottom, left, right, width, color });
                }
            });

            return { camera, rects, lines, framelineNames };
        }
        
        function drawFramelines(data) {
            const { camera, rects, lines, framelineNames } = data;

            // Determine aspect ratio - use selected format if available, otherwise use camera data
            let aspectRatio, displayWidth, displayHeight;
            if (selectedFormat) {
                displayWidth = selectedFormat.sensor_photosites.h;
                displayHeight = selectedFormat.sensor_photosites.v;
                aspectRatio = getAspectRatio(selectedFormat);
            } else {
                displayWidth = camera.hres;
                displayHeight = camera.vres;
                aspectRatio = camera.hres / camera.vres;
            }

            // Set canvas size based on aspect ratio
            // Use a target height and calculate width to maintain aspect ratio
            const targetHeight = 800;
            canvas.height = targetHeight;
            canvas.width = targetHeight * aspectRatio;

            // If width is too large, scale down proportionally
            if (canvas.width > 1200) {
                canvas.width = 1200;
                canvas.height = 1200 / aspectRatio;
            }
            
            // Draw background - image or neutral grey
            if (imageLoaded && backgroundImage && !useGreyGrid) {
                // Draw the background image to fill the canvas
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Use neutral grey (#808080) as fallback or when grey grid is selected
                ctx.fillStyle = '#808080';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw a subtle grid pattern overlay for reference
            ctx.strokeStyle = imageLoaded ? 'rgba(255, 255, 255, 0.1)' : '#111';
            ctx.lineWidth = 0.5;
            const gridSize = Math.min(canvas.width, canvas.height) / 16; // Adaptive grid size
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw rectangles (shading and blackouts)
            rects.forEach(rect => {
                if (rect.opacity > 0) {
                    const x1 = rect.left * canvas.width;
                    const y1 = rect.top * canvas.height;
                    const x2 = canvas.width - (rect.right * canvas.width);
                    const y2 = canvas.height - (rect.bottom * canvas.height);
                    
                    ctx.fillStyle = `rgba(0, 0, 0, ${rect.opacity})`;
                    ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                }
            });
            
            // Draw frame lines
            const lineScale = Math.min(canvas.width / camera.hres, canvas.height / camera.vres);
            lines.forEach(line => {
                // Use the actual color from the XML file
                ctx.strokeStyle = line.color;
                ctx.lineWidth = Math.max(line.width * lineScale, 1); // Ensure lines are at least 1px visible
                
                const x1 = line.left * canvas.width;
                const y1 = line.top * canvas.height;
                const x2 = canvas.width - (line.right * canvas.width);
                const y2 = canvas.height - (line.bottom * canvas.height);
                
                ctx.beginPath();
                
                // Determine if this is a horizontal or vertical line
                if (line.top > 0 && line.bottom === 0) {
                    // Horizontal line at top
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y1);
                } else if (line.bottom > 0 && line.top === 0) {
                    // Horizontal line at bottom
                    ctx.moveTo(x1, y2);
                    ctx.lineTo(x2, y2);
                } else if (line.left > 0 && line.right === 0) {
                    // Vertical line on left
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x1, y2);
                } else if (line.right > 0 && line.left === 0) {
                    // Vertical line on right
                    ctx.moveTo(x2, y1);
                    ctx.lineTo(x2, y2);
                } else if (line.top > 0 && line.bottom > 0) {
                    // Vertical line segment
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x1, y2);
                }
                
                ctx.stroke();
            });
            
            // Update camera info - combine selected camera/format with XML data
            const physicalWidth = camera.physicalWidth || (camera.hres * 0.00825).toFixed(2);
            const physicalHeight = camera.physicalHeight || (camera.vres * 0.00825).toFixed(2);
            const recordingFormat = camera.recordingFormat || 'Unknown';

            let infoHtml = '';

            // Show selected camera and format first if available
            if (selectedCamera) {
                const variantText = selectedCamera.variant ? ` (${selectedCamera.variant})` : '';
                infoHtml += `
                    <div class="info-item">
                        <div class="info-label">Selected Camera</div>
                        <div class="info-value">${selectedCamera.model}${variantText}</div>
                    </div>
                `;
            }

            if (selectedFormat) {
                const formatAspect = getAspectRatio(selectedFormat);
                infoHtml += `
                    <div class="info-item">
                        <div class="info-label">Selected Format</div>
                        <div class="info-value">${selectedFormat.name}</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Format Resolution</div>
                        <div class="info-value">${selectedFormat.sensor_photosites.h} Ã— ${selectedFormat.sensor_photosites.v} (${formatAspect.toFixed(2)}:1)</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Sensor Active Area</div>
                        <div class="info-value">${selectedFormat.sensor_area_mm.h} Ã— ${selectedFormat.sensor_area_mm.v} mm (${selectedFormat.sensor_area_inch.h}" Ã— ${selectedFormat.sensor_area_inch.v}")</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Image Circle</div>
                        <div class="info-value">${selectedFormat.image_circle_mm} mm (${selectedFormat.image_circle_inch}")</div>
                    </div>
                `;
            }

            // Add XML information
            infoHtml += `
                <div class="info-item">
                    <div class="info-label">XML Camera Model</div>
                    <div class="info-value">${camera.type}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">XML Recording Format</div>
                    <div class="info-value">${recordingFormat}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">XML Resolution</div>
                    <div class="info-value">${camera.hres} Ã— ${camera.vres} (${camera.aspect.toFixed(2)}:1)</div>
                </div>
            `;

            // Add sensor area if not already shown from selected format
            if (!selectedFormat) {
                infoHtml += `
                    <div class="info-item">
                        <div class="info-label">XML Sensor Active Area</div>
                        <div class="info-value">${physicalWidth} Ã— ${physicalHeight} mm</div>
                    </div>
                `;
            }

            // Add frameline statistics
            const framelineNamesArray = framelineNames ? Object.values(framelineNames) : [];
            if (framelineNamesArray.length > 0) {
                infoHtml += `
                    <div class="info-item">
                        <div class="info-label">Frameline Formats</div>
                        <div class="info-value">${framelineNamesArray.join(', ')}</div>
                    </div>
                `;
            }

            infoHtml += `
                <div class="info-item">
                    <div class="info-label">Shading Rectangles</div>
                    <div class="info-value">${rects.length} total (${rects.filter(r => r.opacity === 1.0).length} blackouts, ${rects.filter(r => r.opacity > 0 && r.opacity < 1).length} dimming)</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Frame Lines</div>
                    <div class="info-value">${lines.length} total</div>
                </div>
            `;

            cameraInfoDiv.innerHTML = infoHtml;
        }

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const xmlText = e.target.result;
                    frameData = parseXML(xmlText);
                    drawFramelines(frameData);
                } catch (error) {
                    showError(`Error loading XML: ${error.message}`);
                    console.error(error);
                }
            };
            reader.readAsText(file);
        });
        
        // Function to draw placeholder
        function drawPlaceholder() {
            // Use selected format aspect ratio if available
            if (selectedFormat) {
                const aspectRatio = getAspectRatio(selectedFormat);
                const targetHeight = 800;
                canvas.height = targetHeight;
                canvas.width = targetHeight * aspectRatio;

                if (canvas.width > 1200) {
                    canvas.width = 1200;
                    canvas.height = 1200 / aspectRatio;
                }
            } else {
                canvas.width = 1200;
                canvas.height = 900;
            }

            ctx.fillStyle = '#808080'; // Neutral grey
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw a subtle grid pattern overlay for reference
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;
            const gridSize = Math.min(canvas.width, canvas.height) / 16; // Adaptive grid size
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            ctx.fillStyle = '#333';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Load an XML file to visualize framelines', canvas.width / 2, canvas.height / 2);
        }
        
        // Load camera formats on page load
        loadCameraFormats();

        // Set initial state - grey grid as default
        useGreyGrid = true;
        setActiveButton(useGreyGridBtn);
        drawPlaceholder();

        function populateXmlFileList() {
            xmlFileList.innerHTML = '';
            xmlFiles.forEach(file => {
                const listItem = document.createElement('li');
                listItem.classList.add('xml-file-item');
                listItem.dataset.filename = file;

                const fileNameSpan = document.createElement('span');
                fileNameSpan.classList.add('xml-file-name');
                fileNameSpan.textContent = file;

                const downloadLink = document.createElement('a');
                downloadLink.classList.add('xml-file-download');
                downloadLink.textContent = 'Download';
                downloadLink.href = `xmls/${file}`;
                downloadLink.download = file;

                listItem.appendChild(fileNameSpan);
                listItem.appendChild(downloadLink);
                xmlFileList.appendChild(listItem);
            });
        }

        function loadXmlFromUrl(url) {
            fetch(url)
                .then(response => response.text())
                .then(xmlText => {
                    try {
                        frameData = parseXML(xmlText);
                        drawFramelines(frameData);
                        xmlLibraryPopup.style.display = 'none';
                    } catch (error) {
                        showError(`Error loading XML: ${error.message}`);
                        console.error(error);
                    }
                })
                .catch(error => {
                    showError(`Error fetching XML: ${error.message}`);
                    console.error(error);
                });
        }

        selectFromLibraryBtn.addEventListener('click', () => {
            xmlLibraryPopup.style.display = 'flex';
            populateXmlFileList();
        });

        closePopupBtn.addEventListener('click', () => {
            xmlLibraryPopup.style.display = 'none';
        });

        xmlFileList.addEventListener('click', (event) => {
            const target = event.target;
            if (target.classList.contains('xml-file-download')) {
                // Allow download link to work as normal
                return;
            }

            const listItem = target.closest('.xml-file-item');
            if (listItem) {
                const filename = listItem.dataset.filename;
                const fileUrl = `xmls/${filename}`;
                loadXmlFromUrl(fileUrl);
            }
        });
    </script>
</body>
</html>