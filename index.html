<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARRI Alexa Mini Framelines Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #fff;
            font-size: 28px;
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            color: #888;
            font-size: 14px;
        }
        
        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 14px;
        }
        
        input[type="file"] {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
        }
        
        input[type="file"]::file-selector-button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        input[type="file"]::file-selector-button:hover {
            background: #0052a3;
        }
        
        .bg-option-btn {
            background: #0066cc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            flex: 1;
            font-size: 13px;
            transition: background 0.2s;
        }
        
        .bg-option-btn:hover {
            background: #0052a3;
        }
        
        .bg-option-btn.active {
            background: #00cc66;
        }
        
        .viewer {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 600px;
        }
        
        .canvas-container {
            position: relative;
            background: #000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        
        canvas {
            display: block;
            image-rendering: crisp-edges;
        }
        
        .info {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .info h3 {
            margin-bottom: 10px;
            color: #fff;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .info-item {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
        }
        
        .info-label {
            color: #888;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .info-value {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
        }
        
        .error {
            background: #ff4444;
            color: white;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }
        
        .legend {
            margin-top: 15px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 4px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 30px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #444;
        }
        
        .legend-label {
            font-size: 13px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ARRI Alexa Mini Framelines Visualizer</h1>
        <div class="subtitle">Visualize your framelines XML</div>
        
        <div class="error" id="error"></div>
        
        <div class="controls">
            <div class="control-group">
                <label for="xmlFile">Load Framelines XML File:</label>
                <input type="file" id="xmlFile" accept=".xml" />
            </div>
            <div class="control-group">
                <label>Background Options:</label>
                <div style="display: flex; gap: 10px; margin-top: 8px;">
                    <button id="useCustomImage" class="bg-option-btn">Upload Custom Image</button>
                    <button id="useSampleImage" class="bg-option-btn">Use Sample Image</button>
                    <button id="useGreyGrid" class="bg-option-btn">Use Grey Grid</button>
                </div>
                <input type="file" id="bgImage" accept="image/*" style="display: none;" />
            </div>
        </div>
        
        <div class="viewer">
            <div class="canvas-container">
                <canvas id="frameCanvas"></canvas>
            </div>
        </div>
        
        <div class="info">
            <h3>Camera Information</h3>
            <div class="info-grid" id="cameraInfo"></div>
            
            <div class="legend">
                <h3 style="margin-bottom: 10px; font-size: 16px;">Legend</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(0,0,0,0.25);"></div>
                    <div class="legend-label">25% Dimming (Original shading)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(0,0,0,1);"></div>
                    <div class="legend-label">100% Blackout (Corner squares)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: transparent; border: 2px solid #00ff00;"></div>
                    <div class="legend-label">Frame Lines</div>
                </div>
            </div>
        </div>
    </div>
    
    <footer style="text-align: center; margin-top: 30px; padding: 20px; color: #888; font-size: 14px;">
        You don't like it? Please fix it yourself :D Here's the github: <a href="https://github.com/JensS/arri-frameline-visualizer" style="color: #0066cc; text-decoration: none;">https://github.com/JensS/arri-frameline-visualizer</a>
    </footer>
    
    <script>
        const canvas = document.getElementById('frameCanvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('xmlFile');
        const bgImageInput = document.getElementById('bgImage');
        const errorDiv = document.getElementById('error');
        const cameraInfoDiv = document.getElementById('cameraInfo');
        const useCustomImageBtn = document.getElementById('useCustomImage');
        const useSampleImageBtn = document.getElementById('useSampleImage');
        const useGreyGridBtn = document.getElementById('useGreyGrid');
        
        let frameData = null;
        let backgroundImage = null;
        let imageLoaded = false;
        let useGreyGrid = false;
        
        // Sample image path
        const sampleImagePath = 'sample-image-jens-sage-2880-2160.jpg';
        
        // Set active button
        function setActiveButton(activeBtn) {
            [useCustomImageBtn, useSampleImageBtn, useGreyGridBtn].forEach(btn => {
                btn.classList.remove('active');
            });
            activeBtn.classList.add('active');
        }
        
        // Load sample image
        function loadSampleImage() {
            const img = new Image();
            img.onload = function() {
                backgroundImage = img;
                imageLoaded = true;
                useGreyGrid = false;
                if (frameData) {
                    drawFramelines(frameData);
                } else {
                    drawPlaceholder();
                }
            };
            img.onerror = function() {
                showError('Could not load sample image. Using grey grid instead.');
                useGreyGrid = true;
                imageLoaded = false;
                if (frameData) {
                    drawFramelines(frameData);
                } else {
                    drawPlaceholder();
                }
            };
            img.src = sampleImagePath;
        }
        
        // Handle local image upload
        bgImageInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const localImg = new Image();
                localImg.onload = function() {
                    backgroundImage = localImg;
                    imageLoaded = true;
                    useGreyGrid = false;
                    setActiveButton(useCustomImageBtn);
                    if (frameData) {
                        drawFramelines(frameData);
                    } else {
                        drawPlaceholder();
                    }
                };
                localImg.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
        
        // Button event handlers
        useCustomImageBtn.addEventListener('click', () => {
            bgImageInput.click();
        });
        
        useSampleImageBtn.addEventListener('click', () => {
            setActiveButton(useSampleImageBtn);
            loadSampleImage();
        });
        
        useGreyGridBtn.addEventListener('click', () => {
            setActiveButton(useGreyGridBtn);
            backgroundImage = null;
            imageLoaded = false;
            useGreyGrid = true;
            if (frameData) {
                drawFramelines(frameData);
            } else {
                drawPlaceholder();
            }
        });
        
        function showError(message) {
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }
        
        function parseXML(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            
            const errorNode = xmlDoc.querySelector('parsererror');
            if (errorNode) {
                throw new Error('Invalid XML file');
            }
            
            const camera = {
                type: xmlDoc.querySelector('camera > type')?.textContent || 'Unknown',
                sensor: xmlDoc.querySelector('camera > sensor')?.textContent || 'Unknown',
                aspect: parseFloat(xmlDoc.querySelector('camera > aspect')?.textContent || '1.33'),
                hres: parseInt(xmlDoc.querySelector('camera > hres')?.textContent || '2880'),
                vres: parseInt(xmlDoc.querySelector('camera > vres')?.textContent || '2160')
            };
            
            // Try to extract sensor dimensions from comments
            const sensorAreaMatch = xmlText.match(/sensor active image area:\s*([\d.]+)mm\s*x\s*([\d.]+)mm/i);
            if (sensorAreaMatch) {
                camera.physicalWidth = parseFloat(sensorAreaMatch[1]);
                camera.physicalHeight = parseFloat(sensorAreaMatch[2]);
            }
            
            // Extract recording format from comments
            const recordingFormatMatch = xmlText.match(/recording format:\s*(.+?)(?:\n|$)/);
            if (recordingFormatMatch) {
                camera.recordingFormat = recordingFormatMatch[1].trim();
            }
            
            const rects = [];
            const rectElements = xmlDoc.querySelectorAll('rect');
            rectElements.forEach(rect => {
                const top = parseFloat(rect.querySelector('top')?.textContent || '0');
                const bottom = parseFloat(rect.querySelector('bottom')?.textContent || '0');
                const left = parseFloat(rect.querySelector('left')?.textContent || '0');
                const right = parseFloat(rect.querySelector('right')?.textContent || '0');
                const opacity = parseFloat(rect.querySelector('fill > opacity')?.textContent || '0');
                const color = rect.querySelector('fill > color')?.textContent || 'black';
                
                rects.push({ top, bottom, left, right, opacity, color });
            });
            
            const lines = [];
            const lineElements = xmlDoc.querySelectorAll('line');
            lineElements.forEach(line => {
                const framelineRect = line.getAttribute('framelineRect');
                const top = parseFloat(line.querySelector('top')?.textContent || '0');
                const bottom = parseFloat(line.querySelector('bottom')?.textContent || '0');
                const left = parseFloat(line.querySelector('left')?.textContent || '0');
                const right = parseFloat(line.querySelector('right')?.textContent || '0');
                const width = parseInt(line.querySelector('width')?.textContent || '2');
                const color = line.querySelector('color')?.textContent || 'user';
                
                if (framelineRect) {
                    lines.push({ framelineRect, top, bottom, left, right, width, color });
                }
            });
            
            return { camera, rects, lines };
        }
        
        function drawFramelines(data) {
            const { camera, rects, lines } = data;
            
            // Set canvas size based on camera resolution with proper aspect ratio
            // Use a target height and calculate width to maintain aspect ratio
            const targetHeight = 800;
            const aspectRatio = camera.hres / camera.vres;
            canvas.height = targetHeight;
            canvas.width = targetHeight * aspectRatio;
            
            // If width is too large, scale down proportionally
            if (canvas.width > 1200) {
                canvas.width = 1200;
                canvas.height = 1200 / aspectRatio;
            }
            
            // Draw background - image or neutral grey
            if (imageLoaded && backgroundImage && !useGreyGrid) {
                // Draw the background image to fill the canvas
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Use neutral grey (#808080) as fallback or when grey grid is selected
                ctx.fillStyle = '#808080';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw a subtle grid pattern overlay for reference
            ctx.strokeStyle = imageLoaded ? 'rgba(255, 255, 255, 0.1)' : '#111';
            ctx.lineWidth = 0.5;
            const gridSize = Math.min(canvas.width, canvas.height) / 16; // Adaptive grid size
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw rectangles (shading and blackouts)
            rects.forEach(rect => {
                if (rect.opacity > 0) {
                    const x1 = rect.left * canvas.width;
                    const y1 = rect.top * canvas.height;
                    const x2 = canvas.width - (rect.right * canvas.width);
                    const y2 = canvas.height - (rect.bottom * canvas.height);
                    
                    ctx.fillStyle = `rgba(0, 0, 0, ${rect.opacity})`;
                    ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                }
            });
            
            // Draw frame lines
            const lineScale = Math.min(canvas.width / camera.hres, canvas.height / camera.vres);
            lines.forEach(line => {
                const color = line.color === 'user' ? '#00ff00' : '#ffffff';
                ctx.strokeStyle = color;
                ctx.lineWidth = Math.max(line.width * lineScale, 1); // Ensure lines are at least 1px visible
                
                const x1 = line.left * canvas.width;
                const y1 = line.top * canvas.height;
                const x2 = canvas.width - (line.right * canvas.width);
                const y2 = canvas.height - (line.bottom * canvas.height);
                
                ctx.beginPath();
                
                // Determine if this is a horizontal or vertical line
                if (line.top > 0 && line.bottom === 0) {
                    // Horizontal line at top
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y1);
                } else if (line.bottom > 0 && line.top === 0) {
                    // Horizontal line at bottom
                    ctx.moveTo(x1, y2);
                    ctx.lineTo(x2, y2);
                } else if (line.left > 0 && line.right === 0) {
                    // Vertical line on left
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x1, y2);
                } else if (line.right > 0 && line.left === 0) {
                    // Vertical line on right
                    ctx.moveTo(x2, y1);
                    ctx.lineTo(x2, y2);
                } else if (line.top > 0 && line.bottom > 0) {
                    // Vertical line segment
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x1, y2);
                }
                
                ctx.stroke();
            });
            
            // Update camera info
            const physicalWidth = camera.physicalWidth || (camera.hres * 0.00825).toFixed(2);
            const physicalHeight = camera.physicalHeight || (camera.vres * 0.00825).toFixed(2);
            const recordingFormat = camera.recordingFormat || 'Unknown';
            
            cameraInfoDiv.innerHTML = `
                <div class="info-item">
                    <div class="info-label">Camera Model</div>
                    <div class="info-value">${camera.type}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Recording Format</div>
                    <div class="info-value">${recordingFormat}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Recording Aspect</div>
                    <div class="info-value">${camera.aspect.toFixed(2)} (${camera.hres}:${camera.vres})</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Resolution</div>
                    <div class="info-value">${camera.hres} × ${camera.vres}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Sensor Active Area</div>
                    <div class="info-value">${physicalWidth} × ${physicalHeight} mm</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Shading Rectangles</div>
                    <div class="info-value">${rects.length} (${rects.filter(r => r.opacity === 1.0).length} corner blackouts)</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Frame Lines</div>
                    <div class="info-value">${lines.length}</div>
                </div>
            `;
        }
        
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const xmlText = e.target.result;
                    frameData = parseXML(xmlText);
                    drawFramelines(frameData);
                } catch (error) {
                    showError(`Error loading XML: ${error.message}`);
                    console.error(error);
                }
            };
            reader.readAsText(file);
        });
        
        // Function to draw placeholder
        function drawPlaceholder() {
            canvas.width = 1200;
            canvas.height = 900;
            ctx.fillStyle = '#808080'; // Neutral grey
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw a subtle grid pattern overlay for reference
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;
            const gridSize = Math.min(canvas.width, canvas.height) / 16; // Adaptive grid size
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            ctx.fillStyle = '#333';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Load an XML file to visualize framelines', canvas.width / 2, canvas.height / 2);
        }
        
        // Set initial state - grey grid as default
        useGreyGrid = true;
        setActiveButton(useGreyGridBtn);
        drawPlaceholder();
    </script>
</body>
</html>